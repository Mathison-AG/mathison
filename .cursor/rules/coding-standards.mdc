---
description: 
globs: 
alwaysApply: true
---

# Mathison — Coding Standards

Follow these patterns consistently across all code. They're enforced by the team and expected by TypeScript strict mode.

## TypeScript

- `strict: true` — no `any` unless absolutely unavoidable (add a comment explaining why)
- Use `unknown` over `any` for untyped data, then narrow with Zod or type guards
- Use `interface` for object shapes, `type` for unions/intersections/aliases
- Export types from `src/types/` — never define shared types inline in components

## Imports — Consistent Ordering

```typescript
// 1. Node/framework built-ins
import { NextResponse } from "next/server";

// 2. Third-party libraries
import { z } from "zod/v4";
import { streamText } from "ai";

// 3. Internal absolute imports (@/ alias)
import { prisma } from "@/lib/db";
import { auth } from "@/lib/auth";
import { env } from "@/lib/config";

// 4. Relative imports (components, utils in same feature)
import { StatusBadge } from "./status-badge";

// 5. Types (import type when only used for types)
import type { Recipe } from "@/types/recipe";
```

## API Route Pattern

Every API route handler follows this structure:

```typescript
import { NextResponse } from "next/server";
import { auth } from "@/lib/auth";

export async function GET(req: Request) {
  try {
    // 1. Auth check (if protected)
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Input validation (Zod)
    // 3. Business logic
    // 4. Return success
    return NextResponse.json(data);
  } catch (error) {
    console.error("[GET /api/example]", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

Rules:
- Always wrap in try/catch
- Log errors with `[METHOD /api/path]` prefix
- Return `{ error: string }` for errors, never throw raw
- Use `NextResponse.json()` not `new Response()`
- Validate all inputs with Zod — never trust request body

## Zod v4 Validation in Routes

```typescript
import { z } from "zod/v4";

const bodySchema = z.object({
  name: z.string().min(1).max(100),
  config: z.record(z.string(), z.unknown()).optional(),
});

// In the handler:
const parsed = bodySchema.safeParse(await req.json());
if (!parsed.success) {
  return NextResponse.json(
    { error: "Invalid input", details: z.flattenError(parsed.error) },
    { status: 400 }
  );
}
const { name, config } = parsed.data;
```

**Zod v4 specifics:**
- Import from `"zod/v4"` (NOT `"zod"`)
- `z.record()` requires 2 args: `z.record(z.string(), z.unknown())`
- Error flattening: `z.flattenError(parsed.error)` (NOT `parsed.error.flatten()`)

## React Components

- Server Components by default (no directive)
- Add `"use client"` ONLY when the component needs: hooks, event handlers, browser APIs, or context
- Props interface defined above the component, named `{ComponentName}Props`
- Use `function` declarations for components, not arrow functions

```typescript
interface RecipeCardProps {
  recipe: Recipe;
  onDeploy?: (slug: string) => void;
}

export function RecipeCard({ recipe, onDeploy }: RecipeCardProps) {
  return <div>...</div>;
}
```

## Prisma Queries

- Always use the singleton from `@/lib/db` — never instantiate `new PrismaClient()`
- Import from `@/generated/prisma/client` (NOT `@prisma/client`)
- Always scope tenant queries by `tenantId`:
  ```typescript
  prisma.deployment.findMany({
    where: { tenantId: session.user.tenantId },
  })
  ```
- Use `select` or `include` explicitly — don't fetch everything
- Raw SQL only for pgvector queries — use Prisma for everything else
- Prisma JSON casts: `data.configSchema as unknown as Prisma.InputJsonValue`

## Error Messages

- User-facing: clear, helpful, no internals ("Service not found" not "Prisma P2025")
- Logs: include full error + context (`console.error("[deployService]", { recipeSlug, tenantId }, error)`)
- Never expose stack traces, SQL queries, or internal IDs in API responses

## User-facing Language

- **Never expose K8s terminology in the UI**: No "Kubernetes", "K8s", "Helm", "pods", "namespaces", "clusters", "nodes", "YAML"
- Translation: pod → instance/service, namespace → workspace, Helm chart → service template, container → service/app
- Internal code keeps K8s/Helm terminology — only user-facing strings are neutralized

## File Naming

- Components: `kebab-case.tsx` (e.g., `recipe-card.tsx`)
- Libraries: `kebab-case.ts` (e.g., `system-prompt.ts`)
- Types: `kebab-case.ts` in `src/types/`
- API routes: `route.ts` inside the path directory

## Commits

Use clear, descriptive commit messages:
```
feat: short description of what was built

- bullet points of key changes
- note any decisions that affect other areas
```

Prefixes: `feat:`, `fix:`, `refactor:`, `chore:`, `docs:`, `test:`
