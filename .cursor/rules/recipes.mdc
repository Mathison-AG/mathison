---
description: Playbook for adding new recipes to the app catalog. Follow this when creating any new recipe.
globs:
  - src/recipes/**
---

# Recipe Development Playbook

Step-by-step process for adding a new app to the Mathison catalog. Follow this every time.

---

## Phase 1: Research

Before writing any code, answer these questions about the app:

### Container Image
- **Which Docker image?** Check Docker Hub or the project's official docs. Prefer images from the project itself (e.g., `louislam/uptime-kuma`). Bitnami images are solid for databases but not always ideal for apps.
- **What tag?** Use a stable version tag (e.g., `1`, `latest`, or a specific version). Check Docker Hub for available tags.
- **What port?** Find the container's default HTTP/TCP port from the project docs.

### Environment Variables
- **How is it configured?** Most apps use env vars. Check the project's Docker documentation for the full list.
- **Which env vars are required?** Focus on database connection, admin credentials, base URL, storage paths.
- **What are the defaults?** Many apps work with minimal config.

### Storage
- **Does it need persistent storage?** If yes, what path does it write to?
- **What's a sensible default size?** Usually 1Gi–5Gi for app data, 5Gi–20Gi for databases.

### Dependencies
- **Does it need a database?** PostgreSQL, MySQL, MongoDB, SQLite (embedded)?
- **Does it need Redis?** For caching, queues, or sessions?
- **Does it need object storage?** MinIO for file uploads?
- **Are all required dependencies already in the catalog?** If not, add them first.

### Health & Probes
- **Does it have a health endpoint?** (e.g., `/api/health`, `/healthz`, `/`)
- **How long does it take to start?** Sets `initialDelaySeconds`.

### Gotchas
- **Security context requirements?** Some containers need root to start, then drop privileges. Some need specific UID/GID.
- **Init scripts?** Some apps auto-configure on first boot.
- **Multi-component?** Some apps (e.g., Immich) need multiple containers. These are complex — use custom `build()` or defer.

## Phase 2: Implementation

### Step 1 — Create Recipe File

Create `src/recipes/{slug}/index.ts`. Choose the right archetype:

| App Type | Archetype | Examples |
|----------|-----------|----------|
| SQL database | `database()` | PostgreSQL, MySQL |
| Cache/KV store | `cache()` | Redis, Memcached |
| Web application | `webApp()` | Uptime Kuma, Gitea, Vaultwarden |
| Object storage | `objectStore()` | MinIO |
| Complex multi-container | Custom `build()` | n8n (worker mode) |

Reference templates:
- **Simplest webApp**: `src/recipes/uptime-kuma/index.ts` — no deps, no secrets, straightforward
- **WebApp with deps**: `src/recipes/n8n/index.ts` — PostgreSQL dep, secrets, custom build
- **Database**: `src/recipes/postgresql/index.ts` — database archetype, secrets, connection info
- **Cache**: `src/recipes/redis/index.ts` — cache archetype, optional persistence

### Required fields checklist:

```
Identity:        slug, displayName, category, description, tags
Consumer:        shortDescription, useCases (3+), gettingStarted (markdown)
Links:           websiteUrl, documentationUrl
Config:          configSchema (Zod v4, always include cpu/memory request/limit)
Container:       image, imageTag, containerPort
Environment:     env function
Probes:          livenessProbe, readinessProbe
Health:          healthCheck function
AI:              aiHints { summary, whenToSuggest, pairsWellWith }
```

### Optional but recommended:

```
Secrets:         secrets (auto-generated passwords, API keys)
Dependencies:    dependencies (other recipes this needs)
Persistence:     persistence { enabled, mountPath, storageSize }
Ingress:         ingress { enabled, hostnameTemplate, port, serviceNameSuffix }
Data:            dataExport, dataImport (for backup/restore)
Featured:        featured: true (shows in "Popular" section)
```

### Step 2 — Register Recipe

Add to `src/recipes/registry.ts`:

```typescript
import { myRecipe } from "./my-recipe";
// ...
register(myRecipe as RecipeDefinition<unknown>);
```

### Step 3 — Add Icon

Place an SVG icon at `public/icons/{slug}.svg`.
- Should work at 40px and 80px sizes
- Consistent with existing icons in style
- Can source from the project's branding assets, Simple Icons, or similar

### Step 4 — Typecheck

Run `docker compose -f docker-compose.local.yml exec web yarn typecheck` to verify no type errors.

## Phase 3: Testing

**All steps in this phase are REQUIRED before completing a recipe task.** Do not present the recipe for review until every step passes. Recipes must be verified running in the local kind cluster.

### 1. Seed the database

```bash
docker compose -f docker-compose.local.yml exec web npx prisma db seed
```

This creates the DB record and generates embeddings.

### 2. Verify catalog API

```bash
docker compose -f docker-compose.local.yml exec web curl -s http://localhost:3000/api/catalog/{slug} | jq .slug
```

The new app should return its slug.

### 3. Deploy to the local kind cluster

This step is **mandatory**. Start the full local environment and deploy the recipe to verify it actually works end-to-end.

#### Prerequisites
- Docker Compose is running: `docker compose -f docker-compose.local.yml up -d`
- Kind cluster exists: `kind create cluster --name mathison-dev` (if not already running)
- Workspace namespace exists: check with `kubectl --context kind-mathison-dev get ns` and create if missing
- Worker container is healthy: check `docker compose -f docker-compose.local.yml logs worker --tail=5`

#### Deploy and verify
Install via the browser UI (http://localhost:3000 → App Store → Install) or via the install API. Then verify:

```bash
# Watch pods come up
kubectl --context kind-mathison-dev get pods -n <namespace> -w

# Check pod is 1/1 Running (not 0/1, not CrashLoopBackOff)
kubectl --context kind-mathison-dev get pods -n <namespace>

# If not ready, check logs for the actual error
kubectl --context kind-mathison-dev logs <pod-name> -n <namespace> --tail=30

# If crashing, describe for events
kubectl --context kind-mathison-dev describe pod <pod-name> -n <namespace> | tail -20
```

**All pods must reach 1/1 Running.** If a pod fails:
1. Read the logs to identify the root cause
2. Fix the recipe (env vars, command, probes, bind address, etc.)
3. Delete the failed deployment (K8s resources + DB record) and redeploy
4. Repeat until all pods are healthy

Common issues to watch for:
- **Container binds to 127.0.0.1**: K8s probes can't reach it. Fix with config or command override to bind to `0.0.0.0`
- **Wrong entrypoint/CMD**: Check the image's actual Dockerfile CMD before overriding `command`
- **Missing namespace**: Kind cluster was recreated but namespace wasn't re-provisioned
- **Image pull errors**: Verify the image tag exists on the registry
- **Localhost-only auth/pairing**: Some apps auto-approve localhost connections but require device pairing or extra auth for remote access. Port-forward testing (localhost) masks this. Check docs for device auth, pairing, or trusted-origin settings and disable them in the recipe config when the gateway token already provides authentication

#### Verify deployment status in DB

```bash
docker compose -f docker-compose.local.yml exec postgres psql -U mathison -d mathison \
  -c "SELECT d.name, d.status FROM deployments d JOIN recipes r ON d.recipe_id = r.id WHERE r.slug = '{slug}';"
```

All related deployments (app + dependencies) should show `RUNNING`.

### 4. Open the app and verify it works

If the app has a web UI (`hasWebUI: true`):
1. Open the app's URL (check `deployment.url` or `http://localhost:<localPort>`)
2. Verify the page loads — not a blank screen, not a connection error
3. If the app requires credentials (gateway tokens, admin passwords), open the **Credentials** dialog on the app detail page and copy them
4. Complete the app's initial setup (login, connect, configure) and verify core functionality works

If the app is a database or cache:
1. Use the **Connection Info** dialog to get credentials
2. Test the connection (e.g., `psql`, `redis-cli`) from inside the worker container

**The recipe is not done until you've verified the app actually works, not just that pods are running.**

### 5. Cleanup

```bash
# Remove via UI or delete K8s resources + DB records manually
kubectl --context kind-mathison-dev delete all -l app.kubernetes.io/managed-by=mathison -n <namespace>
```

## Phase 4: Validation Checklist

Before committing, verify ALL of the following:

- [ ] Recipe file is clean, follows existing patterns
- [ ] `yarn typecheck` passes
- [ ] `yarn lint` passes (no new errors)
- [ ] Recipe appears in catalog API
- [ ] Consumer metadata complete (shortDescription, useCases, gettingStarted)
- [ ] AI hints accurate (summary, whenToSuggest, pairsWellWith)
- [ ] Icon exists at `public/icons/{slug}.svg`
- [ ] Category is appropriate and exists in the filter list
- [ ] **All pods reached 1/1 Running on the local kind cluster** (Phase 3, step 3)
- [ ] Deployment status is RUNNING in the database (Phase 3, step 3)
- [ ] **App URL verified working end-to-end** — opened in browser, completed initial setup, core functionality confirmed (Phase 3, step 4)

## Common Patterns

### Dependency declaration (webApp that needs PostgreSQL + Redis)

```typescript
dependencies: {
  db: {
    recipe: "postgresql",
    reason: "Stores application data",
    config: { database: "myapp" },
  },
  cache: {
    recipe: "redis",
    reason: "Session storage and caching",
  },
},
```

### Using dependency connection info in env vars

```typescript
env: (ctx) => [
  { name: "DATABASE_URL", value: `postgresql://${ctx.deps?.["db"]?.username}:${ctx.deps?.["db"]?.password}@${ctx.deps?.["db"]?.host}:${ctx.deps?.["db"]?.port}/${ctx.deps?.["db"]?.database}` },
  { name: "REDIS_URL", value: `redis://:${ctx.deps?.["cache"]?.password ?? ""}@${ctx.deps?.["cache"]?.host}:${ctx.deps?.["cache"]?.port}` },
],
```

### Auto-generated secrets

```typescript
secrets: {
  admin_password: {
    description: "Admin user password",
    generate: true,
    length: 24,
  },
  secret_key: {
    description: "Application secret key for sessions/CSRF",
    generate: true,
    length: 32,
  },
},
```

### Standard resource config fields

Always include these in configSchema so users can tune resources:

```typescript
cpu_request: z.string().default("50m"),
memory_request: z.string().default("128Mi"),
cpu_limit: z.string().default("250m"),
memory_limit: z.string().default("256Mi"),
```

## Categories

Valid categories (used in catalog filters):

- `automation` — workflow automation, iPaaS
- `project-management` — task/project tracking
- `communication` — chat, messaging
- `knowledge` — wikis, notes, documentation
- `development` — dev tools, Git, code editors
- `media` — file storage, photos, media management
- `analytics` — dashboards, BI, reporting
- `monitoring` — uptime, metrics, alerting
- `storage` — object storage, file servers
- `database` — databases (often auto-deployed as dependencies)
- `cache` — caching, KV stores
- `security` — password managers, auth, secrets

## Recipe Backlog

See `.cursor/tasks/backlog/recipe-backlog.md` for the prioritized list of recipes to add next.
